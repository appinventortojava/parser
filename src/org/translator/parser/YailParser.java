/* Generated By:JavaCC: Do not edit this line. YailParser.java */
//AppComponent, has hashmap of String, String; key: method, value: actual value of method.
//ArrayList<CodeBlock> ?? 

package org.translator.parser;
import org.translator.java.AppComponent;
import java.util.HashMap;
import java.util.ArrayList;
import org.translator.java.JVar;
import org.translator.java.CodeBlock;
import org.translator.java.ComponentCall;
import org.translator.java.IfStatement;
import org.translator.java.ForEach;
import org.translator.java.ForRange;
import org.translator.java.WhileLoop;
import org.translator.java.Method;

public class YailParser implements YailParserConstants {
  static String packageName = "blank";
  HashMap<String, AppComponent> components = new HashMap<String, AppComponent>();
  ArrayList<JVar> variables = new ArrayList<JVar>();
  ArrayList<CodeBlock> events = new ArrayList<CodeBlock>();
  ArrayList<Method > methods = new ArrayList<Method >();
  HashMap<String, ArrayList<String >> lookUps = new HashMap<String, ArrayList<String >>(); //Delete this
  {try {
  buildTable();
  } catch (ParseException e) {
  e.printStackTrace();
  }
  }
  CodeBlock codeBlock;
  boolean isSubEvent; //is in a code block
  boolean hasElse;
  boolean hasRandom; //check to see if an instance of random has been created
  boolean isParam; //check to see if line is a param of a function or a new function call
  String parentEvent; //may be useless
  //global vars
  ComponentCall globalCall;

  final public void addComp() throws ParseException {
 Token parentName = null; Token compType = null; Token compName = null;
    jj_consume_token(ADDCOMP);
    parentName = jj_consume_token(COMPNAME);
    compType = jj_consume_token(COMPNAME);
    compName = jj_consume_token(COMPNAME);
   AppComponent appComponent = new AppComponent(parentName.image);
     appComponent.setType(compType.image);
     appComponent.setComponentName(compName.image);
     components.put(appComponent.getComponentName(), appComponent);
  }

  final public void addComps() throws ParseException {
    addComp();
    compSet();
  }

  final public void afterFormBody() throws ParseException {
    jj_consume_token(LPAREN);
    afterFormBodyS();
    jj_consume_token(RPAREN);
  }

  final public void afterFormBodyS() throws ParseException {
    setProp();
  }

  final public void beginBody() throws ParseException {
    jj_consume_token(LPAREN);
    jj_consume_token(BEGIN);
    eventBody();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANYTEXT:
      jj_consume_token(ANYTEXT);
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
  }

  final public ArrayList callComponents() throws ParseException {
 Token propName; Token callName; ArrayList paramList = new ArrayList(); ArrayList propValObject = new ArrayList();
    jj_consume_token(CALLCOMP);
    propName = jj_consume_token(PROPNAME);
    callName = jj_consume_token(PROPNAME);
    paramList = listParams();
    setPropType();
   ComponentCall compCall = new ComponentCall(propName.image.replace("'",""));
   compCall.setMethod(callName.image.replace("'",""));
   if (paramList.size() > 1)
   {
     for(int i = 0; i < paramList.size(); i++)
     {
      compCall.addArgument(((ArrayList)paramList.get(i)).get(0).toString());
     }
   }
   else if(paramList.size() == 1) compCall.addArgument(((ArrayList)paramList.get(0)).get(0).toString());

   if(!isSubEvent)codeBlock.addCall(compCall);

   String call = propName.image.replace("'","") + "." + callName.image.replace("'","") + "(";

   for(Object list : paramList)
   {

                call = call + ((ArrayList)list).get(0).toString();

   }
   call = call + ")";
   propValObject.add(call);

   {if (true) return propValObject;}
    throw new Error("Missing return statement in function");
  }

  final public void compBody() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ADDCOMP:
      addComps();
      break;
    case DEFINEEVENT:
      defEvent();
      break;
    case DOAFTERFORM:
      doAfterForm();
      break;
    case INITRUN:
      initRun();
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void compBodyS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      compBody();
      jj_consume_token(RPAREN);
      compBodyS();
      break;
    default:
      jj_la1[2] = jj_gen;

    }
  }

  final public void compDef() throws ParseException {
 codeBlock = null;
    jj_consume_token(TRIPLE);
    jj_consume_token(COMPNAME);
    compBodyS();
    compDefs();
  }

  final public void compDefs() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRIPLE:
      compDef();
      break;
    default:
      jj_la1[3] = jj_gen;

    }
  }

  final public void compSet() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      setProp();
      jj_consume_token(RPAREN);
      compSet();
      break;
    default:
      jj_la1[4] = jj_gen;

    }
  }

  final public void defs() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      def();
      break;
    default:
      jj_la1[5] = jj_gen;

    }
  }

  final public void def() throws ParseException {
    jj_consume_token(LPAREN);
    jj_consume_token(DEF);
    defP();
    jj_consume_token(RPAREN);
    defs();
  }

  final public void defP() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      funcDef();
      break;
    case COMPNAME:
      varDef();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void defEvent() throws ParseException {
    defEventHeader();
    eventBody();
  }

  final public CodeBlock defEventHeader() throws ParseException {
 Token compName; Token methodName; isSubEvent = true;
    jj_consume_token(DEFINEEVENT);
    compName = jj_consume_token(COMPNAME);
    methodName = jj_consume_token(COMPNAME);
         codeBlock = new CodeBlock(compName.image); codeBlock.setMethod(methodName.image);
    jj_consume_token(LPAREN);
    eventParams();
    jj_consume_token(RPAREN);
   if(components.get(codeBlock.getComponent()) != null)
    setParamTypes(components.get(codeBlock.getComponent()).getType(), codeBlock.getMethod());
  events.add(codeBlock);

   isSubEvent = false; {if (true) return codeBlock;}
    throw new Error("Missing return statement in function");
  }

  final public void setParamTypes(String type, String method) throws ParseException {
  if(method.contentEquals("MessageReceived") && type.contentEquals("Texting"))
  {
        codeBlock.addArgType("(String)");
        codeBlock.addArgType("(String)");
  }
  else if(method.contentEquals("AfterPicture") && type.contentEquals("Camera"))
  {
        codeBlock.addArgType("(String)");
  }
  else if(method.contentEquals("Dragged") && type.contentEquals("Canvas"))
  {
        codeBlock.addArgType("(Float)");
        codeBlock.addArgType("(Float)");
        codeBlock.addArgType("(Float)");
        codeBlock.addArgType("(Float)");
        codeBlock.addArgType("(Float)");
        codeBlock.addArgType("(Float)");
        codeBlock.addArgType("(Boolean)");
  }
  else if(method.contentEquals("Touched") && type.contentEquals("Canvas"))
  {
        codeBlock.addArgType("(Float)");
        codeBlock.addArgType("(Float)");
        codeBlock.addArgType("(Boolean)");
  }
  else if(method.contentEquals("Touched") && type.contentEquals("ImageSprite"))
  {
        codeBlock.addArgType("(Float)");
        codeBlock.addArgType("(Float)");
  }
  else if(method.contentEquals("LocationChanged") && type.contentEquals("LocationSensor"))
  {
        codeBlock.addArgType("(Double)");
        codeBlock.addArgType("(Double)");
        codeBlock.addArgType("(Double)");
  }
  }

  final public void defineForm() throws ParseException {
  Token packageNameToken;
    jj_consume_token(LPAREN);
    jj_consume_token(DEFINEFORM);
    packageNameToken = jj_consume_token(FORMNAME);
    jj_consume_token(COMPNAME);
    jj_consume_token(RPAREN);
    packageName = packageNameToken.image.toString().substring(0, packageNameToken.image.lastIndexOf("."));
  }

  final public void doAfterForm() throws ParseException {
    jj_consume_token(DOAFTERFORM);
    label_1:
    while (true) {
      afterFormBody();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_1;
      }
    }
  }

  final public void eventBody() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      label_2:
      while (true) {
        eventBodyS();
                            isParam = true;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CALLCOMP:
        case CALLPRIM:
        case COLORVAL:
        case DECIMALVAL:
        case FOREACH:
        case FORRANGE:
        case GETVAR:
        case GETCOMPONENT:
        case IF:
        case LEXVAL:
        case LPAREN:
        case RUNTIMEVAL:
        case SETPROP:
        case SETTHISFORM:
        case SETVAR:
        case TRUE:
        case WHILE:
        case YAILEQUAL:
        case ANYTEXT:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_2;
        }
      }
                                                isParam = false; if(globalCall != null)codeBlock.addCall(globalCall); globalCall = null;
      jj_consume_token(RPAREN);
      eventBody();
      break;
    default:
      jj_la1[9] = jj_gen;

    }
  }

  final public String eventBodyS() throws ParseException {
 Token t = null; ArrayList propValObject;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CALLCOMP:
      callComponents();
                    {if (true) return null;}
      break;
    case FOREACH:
      forEachBlock();
                  {if (true) return null;}
      break;
    case FORRANGE:
      forRangeBlock();
                   {if (true) return null;}
      break;
    case LPAREN:
      t = getVarProp();
                    if (t != null) {if (true) return t.image;} else {if (true) return "";}
      break;
    case COLORVAL:
    case DECIMALVAL:
    case GETVAR:
    case GETCOMPONENT:
    case RUNTIMEVAL:
    case TRUE:
    case ANYTEXT:
      propValObject = propVal(false);
                                                                        if(propValObject.get(0) instanceof ArrayList)
                                                                                {if (true) return ((ArrayList)propValObject.get(0)).get(0).toString();}
                                                                        else
                                                                                {if (true) return propValObject.get(0).toString();}
      break;
    case IF:
      ifBlock();
             {if (true) return null;}
      break;
    case SETPROP:
      setProp();
             {if (true) return null;}
      break;
    case SETTHISFORM:
      setThisForm();
                 {if (true) return null;}
      break;
    case SETVAR:
      setVariables();
                  {if (true) return null;}
      break;
    case WHILE:
      yailControlWhile();
                      {if (true) return null;}
      break;
    case CALLPRIM:
    case LEXVAL:
    case YAILEQUAL:
      yailPrims();
                {if (true) return null;}
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void eventParams() throws ParseException {
 Token param;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMPNAME:
      param = jj_consume_token(COMPNAME);
                        codeBlock.addArg(param.image);
      eventParams();
      break;
    default:
      jj_la1[11] = jj_gen;

    }
  }

  final public void funcBody() throws ParseException {
    eventBody();
  }

  final public void funcBodyS() throws ParseException {
    eventBodyS();
  }

  final public void funcDef() throws ParseException {
    funcName();
    funcBody();
  }

  final public void funcName() throws ParseException {
 Token compName; Token arg; ArrayList<String > argList = new ArrayList<String >();
    jj_consume_token(LPAREN);
    compName = jj_consume_token(COMPNAME);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMPNAME:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_3;
      }
      arg = jj_consume_token(COMPNAME);
                                                           argList.add(arg.image);
    }
    jj_consume_token(RPAREN);
   codeBlock = new CodeBlock("method");
   codeBlock.setB1(true);
   methods.add(new Method(compName.image, codeBlock, argList));
  }

  final public ArrayList getProp() throws ParseException {
 ArrayList propValObject = new ArrayList(); Token compName; Token propName;
    jj_consume_token(GETPROP);
    compName = jj_consume_token(PROPNAME);
    propName = jj_consume_token(PROPNAME);
   String getProperty = compName.image.replace("'", "") + "." + propName.image.replace("'", "") + "()";
    propValObject.add(getProperty);
    if(isParam) globalCall.addArgument(getProperty);
        {if (true) return propValObject;}
    throw new Error("Missing return statement in function");
  }

  final public Token getVar() throws ParseException {
 Token compName;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GETVAR:
      jj_consume_token(GETVAR);
      break;
    case GETCOMPONENT:
      jj_consume_token(GETCOMPONENT);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    compName = jj_consume_token(COMPNAME);
    {if (true) return compName;}
    throw new Error("Missing return statement in function");
  }

  final public Token getVarProp() throws ParseException {
 Token listName = null; ArrayList argsList;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GETVAR:
      listName = getVariables();
      break;
    case GETPROP:
      getProp();
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLORVAL:
      case DECIMALVAL:
      case GETVAR:
      case GETCOMPONENT:
      case LPAREN:
      case RUNTIMEVAL:
      case TRUE:
      case ANYTEXT:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_4;
      }
      argsList = propVal(false);
                              globalCall.addArgument(argsList.get(0).toString());
    }
   {if (true) return listName;}
    throw new Error("Missing return statement in function");
  }

  final public Token getVariables() throws ParseException {
 Token listName;
    jj_consume_token(GETVAR);
    listName = jj_consume_token(COMPNAME);
    //Might be a problem
        if(!isParam)
        {
                ComponentCall compCall = new ComponentCall("");
                compCall.setMethod(listName.image);
                globalCall = compCall;
        }
        else
        {
          globalCall.addArgument(listName.image);
        }
    {if (true) return listName;}
    throw new Error("Missing return statement in function");
  }

  final public void headers() throws ParseException {
    defineForm();
    requires();
  }

  final public void ifBlock() throws ParseException {
 String operator; CodeBlock mainBlock = codeBlock; CodeBlock elseBlock; isSubEvent = true;
   mainBlock.addCall(new ComponentCall("if", ""));
  codeBlock = new CodeBlock("if");
    jj_consume_token(IF);
    operator = ifTest();
    beginBody();
   IfStatement ifStat = new IfStatement(null, null, operator, codeBlock);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    codeBlock = new CodeBlock("else");
      beginBody();
     ifStat.setElseNoCon(codeBlock);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
     mainBlock.addIf(ifStat);
     codeBlock = mainBlock;
     isSubEvent = false;
  }

  final public void forEachBlock() throws ParseException {
 CodeBlock mainBlock = codeBlock; Token var; String type = "String"; String listName;
   mainBlock.addCall(new ComponentCall("foreach", "")); codeBlock = new CodeBlock("foreach");
    jj_consume_token(FOREACH);
    var = jj_consume_token(COMPNAME);
    beginBody();
    listName = eventBodyS();
   mainBlock.addForEach(new ForEach(type, listName, var.image, codeBlock));
   codeBlock = mainBlock;
  }

  final public void forRangeBlock() throws ParseException {
 CodeBlock mainBlock = codeBlock; Token var; Token increment; Token end; Token start;
   mainBlock.addCall(new ComponentCall("forrange", "")); codeBlock = new CodeBlock("forrange");
    jj_consume_token(FORRANGE);
    var = jj_consume_token(COMPNAME);
    beginBody();
    increment = jj_consume_token(DECIMALVAL);
    end = jj_consume_token(DECIMALVAL);
    start = jj_consume_token(DECIMALVAL);
   mainBlock.addForRange(new ForRange(var.image, increment.image, end.image, start.image, codeBlock));
   codeBlock = mainBlock;
  }

  final public String ifTest() throws ParseException {
 Token test; ArrayList paramList = new ArrayList(); String operators;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CALLPRIM:
      case LEXVAL:
      case YAILEQUAL:
        paramList = yailPrims();
        break;
      case GETPROP:
        paramList = getProp();
        break;
      case AND:
      case OR:
        operators = ifTests();
                                                                                       paramList.add(operators);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RPAREN);
              {if (true) return paramList.get(0).toString();}
      break;
    case TRUE:
      test = jj_consume_token(TRUE);
                    {if (true) return "true";}
      break;
    case RUNTIMEVAL:
      test = jj_consume_token(RUNTIMEVAL);
                          {if (true) return "false";}
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String ifTests() throws ParseException {
 String condition1; String condition2; String operator;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AND:
      jj_consume_token(AND);
                   operator = "&&";
      break;
    case OR:
      jj_consume_token(OR);
                                              operator = "||";
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    condition1 = ifTest();
    condition2 = ifTest();
         {if (true) return condition1 + operator + condition2;}
    throw new Error("Missing return statement in function");
  }

  final public void initRun() throws ParseException {
    jj_consume_token(INITRUN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RUNTIMEVAL:
      jj_consume_token(RUNTIMEVAL);
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
  }

  final public ArrayList listParams() throws ParseException {
 ArrayList paramList = new ArrayList(); ArrayList propValObject;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIST:
      jj_consume_token(LIST);
      break;
    case LISTFORRUNTIME:
      jj_consume_token(LISTFORRUNTIME);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLORVAL:
      case DECIMALVAL:
      case GETVAR:
      case GETCOMPONENT:
      case LPAREN:
      case RUNTIMEVAL:
      case TRUE:
      case ANYTEXT:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_5;
      }
      propValObject = propVal(false);
      paramList.add(propValObject);
    }
    jj_consume_token(RPAREN);
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList listStuff() throws ParseException {
 Token t; ArrayList paramList = new ArrayList(); ArrayList propValObject;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIST:
      jj_consume_token(LIST);
      break;
    case LISTFORRUNTIME:
      jj_consume_token(LISTFORRUNTIME);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLORVAL:
      case DECIMALVAL:
      case GETVAR:
      case GETCOMPONENT:
      case LPAREN:
      case RUNTIMEVAL:
      case TRUE:
      case ANYTEXT:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_6;
      }
      propValObject = propVal(true);
                                                                   paramList.add(propValObject);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      propValObject = listStuffP();
                                   paramList.add(propValObject);
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList listStuffP() throws ParseException {
 ArrayList propValList = new ArrayList();
    jj_consume_token(LPAREN);
    propValList = listStuffS();
    jj_consume_token(RPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMALVAL:
    case LPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        propValList = listStuffS();
        jj_consume_token(RPAREN);
        break;
      case DECIMALVAL:
        jj_consume_token(DECIMALVAL);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANYTEXT:
      jj_consume_token(ANYTEXT);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
     {if (true) return propValList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList listStuffS() throws ParseException {
 ArrayList propValList = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEXVAL:
      propValList = compVal();
                           {if (true) return propValList;}
      break;
    case GETPROP:
      propValList = getProp();
                           {if (true) return propValList;}
      break;
    case GETVAR:
    case GETCOMPONENT:
      getVar();
            {if (true) return propValList;}
      break;
    case CALLPRIM:
    case YAILEQUAL:
      propValList = yailPrims();
                             {if (true) return propValList;}
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList makeList() throws ParseException {
 ArrayList paramList = new ArrayList(); String type = "YailList"; ArrayList propValObject;
    jj_consume_token(MAKELIST);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIST:
      jj_consume_token(LIST);
      break;
    case LISTFORRUNTIME:
      jj_consume_token(LISTFORRUNTIME);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COLORVAL:
        case DECIMALVAL:
        case GETVAR:
        case GETCOMPONENT:
        case LPAREN:
        case RUNTIMEVAL:
        case TRUE:
        case ANYTEXT:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_7;
        }
        propValObject = propVal(true);
       if(propValObject.size() > 1) {paramList.add(propValObject);} else {paramList.add(propValObject.get(0));}
      }
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
    jj_consume_token(APOS);
    jj_consume_token(LPAREN);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMPNAME:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMPNAME);
    }
    jj_consume_token(RPAREN);
    jj_consume_token(LISTINIT);
   paramList.add(type);

  {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList opBlock() throws ParseException {
 ArrayList paramList = new ArrayList(); String type = "YailList"; ArrayList propValObject = new ArrayList();
 String operator;
    operator = operation();
    propValObject = listParams();
    setPropType();
    String leftSide = ((ArrayList)propValObject.get(0)).get(0).toString();
    String rightSide = ((ArrayList)propValObject.get(1)).get(0).toString();
    paramList.add(leftSide + operator + rightSide);
    paramList.add("float");

    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public String operation() throws ParseException {
 Token operator; Token equal = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIVIDE:
      jj_consume_token(DIVIDE);
              {if (true) return "/";}
      break;
    case PLUS:
      operator = jj_consume_token(PLUS);
                       {if (true) return operator.image;}
      break;
    case MINUS:
      operator = jj_consume_token(MINUS);
                        {if (true) return operator.image;}
      break;
    case YAILEQUAL:
      operator = jj_consume_token(YAILEQUAL);
                            {if (true) return "==";}
      break;
    case MULTIPLY:
      operator = jj_consume_token(MULTIPLY);
                           {if (true) return operator.image;}
      break;
    case LESS:
      operator = jj_consume_token(LESS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        equal = jj_consume_token(EQUAL);
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
                                            if(equal != null) {if (true) return operator.image+equal.image;} else {if (true) return operator.image;}
      break;
    case GREATER:
      operator = jj_consume_token(GREATER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        equal = jj_consume_token(EQUAL);
        break;
      default:
        jj_la1[34] = jj_gen;
        ;
      }
                                               if(equal != null) {if (true) return operator.image+equal.image;} else {if (true) return operator.image;}
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void primName() throws ParseException {
 Token functionName;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANYTEXT:
      functionName = jj_consume_token(ANYTEXT);
      break;
    default:
      jj_la1[36] = jj_gen;

    }
  }

  final public void program() throws ParseException {
    headers();
    defs();
    compDefs();
    jj_consume_token(0);
  }

//Return type is ArrayList because a property value could be any type (List or String or Number)
  final public ArrayList propVal(boolean inList) throws ParseException {
 Token propertyValue; ArrayList propValList = new ArrayList(); ArrayList tempList;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANYTEXT:
      propertyValue = jj_consume_token(ANYTEXT);
                               propValList.add(propertyValue.image); if(!inList) propValList.add("String"); {if (true) return propValList;}
      break;
    case COLORVAL:
      propertyValue = jj_consume_token(COLORVAL);
                                propValList.add(propertyValue.image); if(!inList) propValList.add("String"); {if (true) return propValList;}
      break;
    case DECIMALVAL:
      propertyValue = jj_consume_token(DECIMALVAL);
                                  propValList.add(propertyValue.image); if(!inList) propValList.add("float"); {if (true) return propValList;}
      break;
    case TRUE:
      propertyValue = jj_consume_token(TRUE);
                            propValList.add("true"); if(!inList) propValList.add("boolean"); {if (true) return propValList;}
      break;
    case RUNTIMEVAL:
      propertyValue = jj_consume_token(RUNTIMEVAL);
                                  propValList.add("false"); if(!inList) propValList.add("boolean"); {if (true) return propValList;}
      break;
    case GETVAR:
    case GETCOMPONENT:
      propertyValue = getVar();
                            propValList.add(propertyValue.image); if(!inList) propValList.add("String"); {if (true) return propValList;}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      tempList = propValS(inList);
      jj_consume_token(RPAREN);
                                                     {if (true) return tempList;}
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList propValS(boolean inList) throws ParseException {
 ArrayList propValObject = new ArrayList(); Token propertyValue;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CALLCOMP:
      propValObject = callComponents();
                                    {if (true) return propValObject;}
      break;
    case GETPROP:
      propValObject = getProp();
                             {if (true) return propValObject;}
      break;
    case GETVAR:
    case GETCOMPONENT:
      propertyValue = getVar();
                            propValObject.add(propertyValue.image); if(!inList) propValObject.add("String"); {if (true) return propValObject;}
      break;
    case IF:
      ifBlock();
             {if (true) return null;}
      break;
    case LEXVAL:
      propValObject = variables();
                               {if (true) return propValObject;}
      break;
    case CALLPRIM:
    case YAILEQUAL:
      propValObject = yailPrims();
                               {if (true) return propValObject;}
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList random() throws ParseException {
 ArrayList paramList = new ArrayList(); boolean randInt; ArrayList propValObject = new ArrayList();
    randInt = randoms();
    paramList = listParams();
    setPropType();
   if(randInt)
  {
    String arg0 = ((ArrayList)paramList.get(0)).get(0).toString();
    String arg1 = ((ArrayList)paramList.get(1)).get(0).toString();
    propValObject.add("random.nextInt("+arg1+"-"+arg0+")"+"+"+arg0);
         {if (true) return propValObject;}
  }
  else
  {propValObject.add("Math.random()");
    {if (true) return propValObject;}
  }
    throw new Error("Missing return statement in function");
  }

  final public boolean randoms() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RANDINT:
      jj_consume_token(RANDINT);
    if(!hasRandom)
        {
     JVar jvar = new JVar("random");
     jvar.setType("Random");
     variables.add(jvar);
     hasRandom = true;
        }
        {if (true) return true;}
      break;
    case RANDFRAC:
      jj_consume_token(RANDFRAC);
                {if (true) return false;}
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void requires() throws ParseException {
    jj_consume_token(LPAREN);
    jj_consume_token(REQUIRE);
    jj_consume_token(PACKAGE);
    jj_consume_token(RPAREN);
  }

  final public void setProp() throws ParseException {
 Token compName; Token propName; Token propType; String propertyName; Object propertyValue;
    jj_consume_token(SETPROP);
    compName = jj_consume_token(PROPNAME);
    propName = jj_consume_token(PROPNAME);
    propertyValue = propVal(true);
    jj_consume_token(PROPTYPE);
    if(components.containsKey(compName.image.replace("'","")) && codeBlock == null)
    {
      AppComponent appComponent = components.get(compName.image.replace("'",""));
      propertyName = propName.image.replace("'", "");
      appComponent.setProperties(propertyName, ((ArrayList)propertyValue).get(0).toString());
    }
    else if(codeBlock != null)
    {
      ComponentCall compCall = new ComponentCall(compName.image.replace("'",""));
      compCall.setMethod(propName.image.replace("'", ""));
      if(((ArrayList)propertyValue).size() > 2)
        compCall.setArgs((ArrayList)propertyValue);
      else
        compCall.addArgument(((ArrayList)propertyValue).get(0).toString());
      codeBlock.addCall(compCall);
  }
  }

  final public void setPropType() throws ParseException {
    jj_consume_token(APOS);
    jj_consume_token(LPAREN);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LIST:
      case COMPNAME:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMPNAME:
        jj_consume_token(COMPNAME);
        break;
      case LIST:
        jj_consume_token(LIST);
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RPAREN);
  }

  final public void setThisForm() throws ParseException {
    jj_consume_token(SETTHISFORM);
  }

  final public void setVariables() throws ParseException {
 JVar jVar; Token varName; ArrayList propValList;
    jj_consume_token(SETVAR);
    varName = jj_consume_token(COMPNAME);
    propValList = propVal(false);
    jVar = new JVar(varName.image); jVar.setVal(propValList.get(0).toString());
  ComponentCall componentCall = new ComponentCall("assignment","");
  if(codeBlock != null)
  {
    codeBlock.addCall(componentCall);
    codeBlock.addAssignment(jVar);
  }
  }

  final public ArrayList stringAppend() throws ParseException {
 ArrayList paramList; ArrayList propValObject = new ArrayList();
    jj_consume_token(STRAPPEND);
    paramList = listParams();
    setPropType();
    StringBuffer appendTo = new StringBuffer();
    for(int i = 0; i < paramList.size(); i++)
    {
      if(i == 0)
      {
        appendTo.append(((ArrayList)paramList.get(i)).get(0).toString());
      }
      else
      {
            appendTo.append(" + " + ((ArrayList)paramList.get(i)).get(0).toString());
      }
    }
    propValObject.add(appendTo.toString());
    {if (true) return propValObject;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringContains() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRCONTAINS);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add(((ArrayList)temp.get(0)).get(0) + ".contains(" + ((ArrayList)temp.get(1)).get(0) + ")");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringEmpty() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STREMPTY);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add(((String)(((ArrayList)temp.get(0)).get(0))) + ".length() < 1");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringGreater() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRGREATER);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add(((ArrayList)temp.get(0)).get(0) + ".compareTo(" + ((ArrayList)temp.get(1)).get(0) + ") > 0");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringLegth() throws ParseException {
  ArrayList paramList;
  ArrayList propValObject = new ArrayList();
    jj_consume_token(STRLEN);
    paramList = listParams();
    setPropType();
    propValObject.add(((ArrayList)paramList.get(0)).get(0) + ".length()");
    {if (true) return propValObject;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringLess() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRLESS);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add(((ArrayList)temp.get(0)).get(0) + ".compareTo(" + ((ArrayList)temp.get(1)).get(0) + ") < 0");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringReplaceAll() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRREPLACEALL);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add(((ArrayList)temp.get(0)).get(0) + ".replaceAll(" + ((ArrayList)temp.get(1)).get(0) + "," + ((ArrayList)temp.get(2)).get(0) + ")");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringSegment() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRSUBSTRING);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add(((ArrayList)temp.get(0)).get(0) + ".substring(" + ((ArrayList)temp.get(1)).get(0) + "-1 ,"+((ArrayList)temp.get(2)).get(0)+"+"+((ArrayList)temp.get(1)).get(0)+"-1)");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringSplit() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRSPLIT);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add(((ArrayList)temp.get(0)).get(0) + ".split(" + ((ArrayList)temp.get(1)).get(0) + ")");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringSplitAtAny() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRSPLITANY);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add("YailList.makeList(" + ((ArrayList)temp.get(0)).get(0) + ".split(" + ((ArrayList)temp.get(1)).get(0) + ".replace(\u005c"[\u005c", \u005c"\u005c").replace(\u005c"]\u005c", \u005c"\u005c").replaceAll(\u005c", \u005c",\u005c"|\u005c")"+"))");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringSplitAtFirst() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRSPLITFIRST);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add("YailList.makeList("+((ArrayList)temp.get(0)).get(0)+".split(\u005c""+((ArrayList)temp.get(1)).get(0)+"\u005c", 2))");

    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringSplitFirstAny() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRSPLITFIRSTANY);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add("YailList.makeList("+((ArrayList)temp.get(0)).get(0)+".split("+((ArrayList)temp.get(1)).get(0)+".replace(\u005c"[\u005c", \u005c"\u005c").replace(\u005c"]\u005c", \u005c"\u005c").replaceAll(\u005c", \u005c",\u005c"|\u005c")"+"))");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringSplitSpaces() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRSPLITSPACES);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add("YailList.makeList("+((ArrayList)temp.get(0)).get(0)+".split(\u005c"\u005c\u005cs+\u005c"))");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringStartsAt() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRSTARTAT);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add(((ArrayList)temp.get(0)).get(0)+".indexOf("+((ArrayList)temp.get(1)).get(0)+")+1");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringTrim() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRTRIM);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add(((ArrayList)temp.get(0)).get(0)+".trim()");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringToLower() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRTOLOWER);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add((((ArrayList)temp.get(0)).get(0)) + ".toLowerCase()");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList stringToUpper() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList propVal = new ArrayList();
    jj_consume_token(STRTOUPPER);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    propVal.add((((ArrayList)temp.get(0)).get(0)) + ".toUpperCase()");
    {if (true) return propVal;}
    throw new Error("Missing return statement in function");
  }

  final public void varDef() throws ParseException {
 JVar var; Token varName; ArrayList propValList;
    varName = jj_consume_token(COMPNAME);
   var = new JVar(varName.image);
    propValList = propVal(false);
     if( ((String) propValList.get(propValList.size()-1)).equals("YailList"))
    {
      var.setType((String) propValList.get(propValList.size()-1));
    propValList.remove(propValList.size()-1);
      var.setMembers(propValList);
    }
    else
    {
      var.setVal(propValList.get(0).toString());
      var.setType(propValList.get(1).toString());
      propValList.remove(1);
    }
   variables.add(var);
  }

  final public ArrayList variables() throws ParseException {
 Token val; ArrayList propValList = new ArrayList();
    jj_consume_token(LEXVAL);
    val = jj_consume_token(COMPNAME);
   propValList.add(val.image); {if (true) return propValList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList compVal() throws ParseException {
 Token val; ArrayList propValList = new ArrayList();;
    jj_consume_token(LEXVAL);
    val = jj_consume_token(COMPNAME);
   propValList.add(val.image); {if (true) return propValList;}
    throw new Error("Missing return statement in function");
  }

  final public void yailControlChoose() throws ParseException {
    ifBlock();
    jj_consume_token(LPAREN);
    listStuff();
    jj_consume_token(RPAREN);
    setPropType();
  }

  final public void yailControlCloseApp() throws ParseException {
 ComponentCall componentCall = new ComponentCall("Form");
  componentCall.setMethod("finishApplication");
    jj_consume_token(CLOSEAPP);
    jj_consume_token(LPAREN);
    listStuff();
    jj_consume_token(RPAREN);
    setPropType();
   codeBlock.addCall(componentCall);
  }

  final public void yailControlCloseScreen() throws ParseException {
  ComponentCall componentCall = new ComponentCall("Form");
  componentCall.setMethod("finishActivity");
    jj_consume_token(CLOSESCREEN);
    jj_consume_token(LPAREN);
    listStuff();
    jj_consume_token(RPAREN);
    setPropType();
   codeBlock.addCall(componentCall);
  }

  final public void yailControlCloseScreenPlainText() throws ParseException {
  ComponentCall componentCall = new ComponentCall("Form");
  componentCall.setMethod("finishActivityWithResult"); ArrayList paramList = null;
    jj_consume_token(CLOSESCREENPLAINTEXT);
    jj_consume_token(LPAREN);
    paramList = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    componentCall.setArgs(paramList); codeBlock.addCall(componentCall);
  }

  final public void yailControlCloseScreenWithValue() throws ParseException {
  ComponentCall componentCall = new ComponentCall("Form");
  componentCall.setMethod("finishActivityWithResult"); ArrayList paramList = null;
    jj_consume_token(CLOSESCREENWITHVALUE);
    jj_consume_token(LPAREN);
    paramList = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
   componentCall.setArgs(paramList); codeBlock.addCall(componentCall);
  }

  final public void yailControlGetPlainStartText() throws ParseException {
    jj_consume_token(GETPLAINSTARTTEXT);
    jj_consume_token(LPAREN);
    listStuff();
    jj_consume_token(RPAREN);
    setPropType();
  }

  final public void yailControlGetStartValue() throws ParseException {
    jj_consume_token(GETSTARTVALUE);
    jj_consume_token(LPAREN);
    listStuff();
    jj_consume_token(RPAREN);
    setPropType();
  }

  final public void yailControlOpenAnotherScreenWithValue() throws ParseException {
  ComponentCall componentCall = new ComponentCall("Form");
  componentCall.setMethod("switchFormWithStartupValue"); ArrayList paramList = null;
    jj_consume_token(OPENANOTHERSCREENWITHVALUE);
    jj_consume_token(LPAREN);
    paramList = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
   componentCall.setArgs(paramList); codeBlock.addCall(componentCall);
  }

  final public void yailControlWhile() throws ParseException {
 String operator; CodeBlock mainBlock = codeBlock;
   mainBlock.addCall(new ComponentCall("while", "")); codeBlock = new CodeBlock("while");
    jj_consume_token(WHILE);
    operator = ifTest();
    beginBody();
   mainBlock.addWhile(new WhileLoop(operator,codeBlock)); codeBlock = mainBlock;
  }

  final public ArrayList yailGetListItem() throws ParseException {
  ArrayList paramList = new ArrayList();
  ArrayList propValObject;
    jj_consume_token(YAILGETITEM);
    jj_consume_token(LPAREN);
    propValObject = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add(propValObject.get(0) + ".getItems().indexOf(" + propValObject.get(1) + ");");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailIsList() throws ParseException {
  ArrayList paramList = new ArrayList();
  ArrayList propValObject;
    jj_consume_token(YAILISALIST);
    jj_consume_token(LPAREN);
    propValObject = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add(propValObject.get(0) + ".getClass().getName().contentEquals(\u005c"YailList\u005c");");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailListAddToList() throws ParseException {
 ArrayList paramList = new ArrayList();
  ArrayList<ComponentCall > compArray = new ArrayList<ComponentCall >();
  Token compName;
    jj_consume_token(YAILADDTOLIST);
    jj_consume_token(LPAREN);
    paramList = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
   ComponentCall compCall = new ComponentCall (((ArrayList)paramList.get(0)).get(0).toString() + "IL");
   compCall.addArgument(((ArrayList)paramList.get(1)).get(0).toString());
     compCall.setMethod("add");
     ComponentCall compCall1 = new ComponentCall(((ArrayList)paramList.get(0)).get(0).toString());
     compCall1.setMethod("setItems");
     compCall1.addArgument(((ArrayList)paramList.get(0)).get(0).toString()+ "IL");

   codeBlock.addCall(compCall);
   codeBlock.addCall(compCall1);
   {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailListRemove() throws ParseException {
 ArrayList paramList = new ArrayList();
  ArrayList<ComponentCall > compArray = new ArrayList<ComponentCall >();
  Token compName;
    compName = jj_consume_token(YAILLISTREMOVE);
    jj_consume_token(LPAREN);
    paramList = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    ComponentCall compCall= new ComponentCall(((ArrayList)paramList.get(0)).get(0).toString() + "IL");
    compCall.addArgument(((ArrayList)paramList.get(1)).get(0).toString());
    compCall.setMethod("remove");
    ComponentCall compCall1 = new ComponentCall(((ArrayList)paramList.get(0)).get(0).toString());
    compCall1.setMethod("setItems");
    compCall1.addArgument(((ArrayList)paramList.get(0)).get(0).toString()+ "IL");

  codeBlock.addCall(compCall);
  codeBlock.addCall(compCall1);
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public void yailListSetItem() throws ParseException {
 ArrayList paramList = new ArrayList();
 Token compName;
    compName = jj_consume_token(YAILLISTSETITEM);
    jj_consume_token(LPAREN);
    paramList = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
   ComponentCall compCall = new ComponentCall(((ArrayList)paramList.get(0)).get(0).toString() + "IL");
    compCall.addArgument(((ArrayList)paramList.get(1)).get(0).toString() + "-1");
    compCall.addArgument(((ArrayList)paramList.get(2)).get(0).toString());
    compCall.setMethod("set");
    ComponentCall compCall1 = new ComponentCall(((ArrayList)paramList.get(0)).get(0).toString());
    compCall1.setMethod("setItems");
    compCall1.addArgument(((ArrayList)paramList.get(0)).get(0).toString() + "IL");
    codeBlock.addCall(compCall);
    codeBlock.addCall(compCall1);
  }

  final public void yailListInsert() throws ParseException {
 ArrayList paramList = new ArrayList();
 ArrayList<ComponentCall > compArray = new ArrayList<ComponentCall >();
 Token compName;
    compName = jj_consume_token(YAILLISTINSERT);
    jj_consume_token(LPAREN);
    paramList = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
   ComponentCall compCall = new ComponentCall(((ArrayList)paramList.get(0)).get(0).toString() + "IL");
    compCall.addArgument(((ArrayList)paramList.get(1)).get(0).toString() + "-1");
    compCall.addArgument(((ArrayList)paramList.get(2)).get(0).toString());
    compCall.setMethod("add");
    ComponentCall compCall1 = new ComponentCall(((ArrayList)paramList.get(0)).get(0).toString());
    compCall1.setMethod("setItems");
    compCall1.addArgument(((ArrayList)paramList.get(0)).get(0).toString() + "IL");
    codeBlock.addCall(compCall);
    codeBlock.addCall(compCall1);
  }

  final public ArrayList yailListAppend() throws ParseException {
 ArrayList paramList = new ArrayList();
  ArrayList<ComponentCall > compArray = new ArrayList<ComponentCall >();
  Token compName;
    compName = jj_consume_token(YAILLISTAPPEND);
    jj_consume_token(LPAREN);
    paramList = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
   ComponentCall compCall= new ComponentCall(((ArrayList)paramList.get(0)).get(0).toString() + "IL");
     compCall.addArgument(((ArrayList)paramList.get(1)).get(0).toString() + "IL");
     compCall.setMethod("addAll");
     ComponentCall compCall1 = new ComponentCall(((ArrayList)paramList.get(0)).get(0).toString());
     compCall1.setMethod("setItems");
     compCall1.addArgument(((ArrayList)paramList.get(0)).get(0).toString());

   codeBlock.addCall(compCall);
   codeBlock.addCall(compCall1);
   {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailListCopy() throws ParseException {
  ArrayList propValObject;
    jj_consume_token(YAILLISTCOPY);
    jj_consume_token(LPAREN);
    propValObject = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    ComponentCall compCall= new ComponentCall("YailList.makeList");
    compCall.setMethod("getItems");
    compCall.addArgument(((ArrayList)propValObject.get(0)).toString());
    codeBlock.addCall(compCall);

    {if (true) return propValObject;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailListFromCsvRow() throws ParseException {
  ArrayList paramList = new ArrayList();
  String type = "YailList";
  ArrayList propValObject;
    jj_consume_token(YAILLISTFROMCSVROW);
    jj_consume_token(LPAREN);
    propValObject = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("CsvUtil.fromCsvRow(YailList.makeList(" + propValObject.get(0) + ".getItems()));");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailListFromCsvTable() throws ParseException {
  ArrayList paramList = new ArrayList();
  String type = "YailList";
  ArrayList propValObject;
    jj_consume_token(YAILLISTFROMCSVTABLE);
    jj_consume_token(LPAREN);
    propValObject = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("CsvUtil.fromCsvTable(YailList.makeList(" + propValObject.get(0) + ".getItems()));");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailListInd() throws ParseException {
  ArrayList paramList = new ArrayList();
  String type = "YailList";
  ArrayList propValObject;
    jj_consume_token(YAILLISTINDEX);
    jj_consume_token(LPAREN);
    propValObject = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add(propValObject.get(1) + ".getItems().indexOf(" + propValObject.get(0) + ");");
    {if (true) return (ArrayList)propValObject.get(0);}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailListLength() throws ParseException {
  ArrayList paramList = new ArrayList();
  String type = "YailList";
  ArrayList propValObject;
    jj_consume_token(YAILLISTLENGTH);
    jj_consume_token(LPAREN);
    propValObject = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    /* test comment please ignore */
    paramList.add(((ArrayList)propValObject.get(0)).size() - 1);
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailListMember() throws ParseException {
  ArrayList paramList = new ArrayList();
  String type = "YailList";
  ArrayList propValObject;
    jj_consume_token(YAILLISTMEMBER);
    jj_consume_token(LPAREN);
    propValObject = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add(propValObject.get(1) + ".getItems().contains(" + propValObject.get(0) + ");");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailListPickRandom() throws ParseException {
  ArrayList paramList = new ArrayList();
  String type = "YailList";
  ArrayList propValObject;
    jj_consume_token(YAILLISTRANDOM);
    jj_consume_token(LPAREN);
    propValObject = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    JVar jvar = new JVar("random");
    jvar.setType("Random");
    variables.add(jvar);

    JVar jvar2 = new JVar("array");
    jvar2.setType("ArrayList");
    variables.add(jvar2);

    for(int i = 0; i < ((ArrayList)propValObject.get(0)).size()-1; i++)
    {
      ComponentCall compCall= new ComponentCall("array");
      compCall.setMethod("add");
      compCall.addArgument(((ArrayList)propValObject.get(0)).get(i).toString());
      codeBlock.addCall(compCall);
    }

    paramList.add("array.get(Math.Random().getInt(array.size())");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailListToCsvRow() throws ParseException {
  ArrayList paramList = new ArrayList();
  String type = "YailList";
  ArrayList propValObject;
    jj_consume_token(YAILLISTTOCSVROW);
    jj_consume_token(LPAREN);
    propValObject = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("CsvUtil.toCsvRow(YailList.makeList(" + propValObject.get(0) + ".getItems()));");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailListToCsvTable() throws ParseException {
  ArrayList paramList = new ArrayList();
  String type = "YailList";
  ArrayList propValObject;
    jj_consume_token(YAILLISTTOCSVTABLE);
    jj_consume_token(LPAREN);
    propValObject = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("CsvUtil.toCsvTable(YailList.makeList(" + propValObject.get(0) + ".getItems()));");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathAbs() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(ABS);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.abs((float)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathAcos() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(ACOS);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.acos((float)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathAtan() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(ATAN);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.atan((float)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathAtan2() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(ATAN2);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.atan2((float)" + ((ArrayList)temp.get(0)).get(0) + ",(float)" + ((ArrayList)temp.get(1)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathAsin() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(ASIN);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.asin((float)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathCeiling() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(CEILING);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.ceil((float)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathConvertToDeg() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(CONVRADITODEG);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.toDegrees((float)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathConvertToRad() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(CONVDEGTORADI);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.toRadians((float)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathcos() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(COS);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.cos((float)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathExp() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(EXP);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.exp((float)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathExpt() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(EXPT);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.pow((float)" + ((ArrayList)temp.get(0)).get(0) + ", (float)" + ((ArrayList)temp.get(1)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathFloor() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(FLOOR);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.floor((float)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathFormatAsDec() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(FORMATASDEC);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("new Double (String.format(\u005c"%."+ ((ArrayList)temp.get(1)).get(0) +"g%n\u005c", "+((ArrayList)temp.get(0)).get(0)+"))");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathIsANum() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(ISANUM);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("\u005c"" + ((ArrayList)temp.get(0)).get(0) + "\u005c"" + ".replaceAll(\u005c"\u005c\u005cd+(.\u005c\u005cd+)*\u005c", \u005c"\u005c").length()<1");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathLog() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(LOG);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.log((float)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathMax() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(MAX);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.max((float)" + ((ArrayList)temp.get(0)).get(0) + ", (float)" + ((ArrayList)temp.get(1)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathMin() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(MIN);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.min((float)" + ((ArrayList)temp.get(0)).get(0) + ", (float)" + ((ArrayList)temp.get(1)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathMod() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(MOD);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("(float)" + ((ArrayList)temp.get(0)).get(0) + " % " + "(float)" + ((ArrayList)temp.get(1)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathNegate() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(MINUS);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("(double)" + ((ArrayList)temp.get(0)).get(0) + "* -1");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathQuotient() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(QUOTIENT);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("(float)" + ((ArrayList)temp.get(0)).get(0) + " / " + "(float)" + ((ArrayList)temp.get(1)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathRandomSeed() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(RANDOMSETSEED);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    if(!hasRandom)
    {
     JVar jvar = new JVar("random");
     jvar.setType("Random");
     variables.add(jvar);
     hasRandom = true;

    }
    paramList.add("random.setSeed((double)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathRemainder() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(REMAINDER);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.IEEEremainder((double)" + ((ArrayList)temp.get(0)).get(0) + ", (double)" + ((ArrayList)temp.get(1)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathRound() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(ROUND);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.round((double)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathsin() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(SIN);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.sin((double)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathSqrt() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(SQUAREROOT);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.sqrt((double)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailMathtan() throws ParseException {
  ArrayList temp = new ArrayList();
  ArrayList paramList = new ArrayList();
    jj_consume_token(TAN);
    jj_consume_token(LPAREN);
    temp = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
    paramList.add("Math.tan((double)" + ((ArrayList)temp.get(0)).get(0) + ")");
    {if (true) return paramList;}
    throw new Error("Missing return statement in function");
  }

  final public void yailControlOpenAnotherScreen() throws ParseException {
  ComponentCall componentCall = new ComponentCall("Form");
  componentCall.setMethod("switchForm"); ArrayList paramList = null;
    jj_consume_token(OPENANOTHERSCREEN);
    jj_consume_token(LPAREN);
    paramList = listStuff();
    jj_consume_token(RPAREN);
    setPropType();
   componentCall.setArgs(paramList); codeBlock.addCall(componentCall);
  }

  final public ArrayList yailPrim() throws ParseException {
 ArrayList propValObject = new ArrayList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAKELIST:
      propValObject = makeList();
                              {if (true) return propValObject;}
      break;
    case YAILLISTREMOVE:
      propValObject = yailListRemove();
                                    {if (true) return propValObject;}
      break;
    case RANDFRAC:
    case RANDINT:
      propValObject = random();
                            {if (true) return propValObject;}
      break;
    case STRAPPEND:
      propValObject = stringAppend();
                                  {if (true) return propValObject;}
      break;
    case STRCONTAINS:
      propValObject = stringContains();
                                    {if (true) return propValObject;}
      break;
    case STREMPTY:
      propValObject = stringEmpty();
                                 {if (true) return propValObject;}
      break;
    case STRGREATER:
      propValObject = stringGreater();
                                   {if (true) return propValObject;}
      break;
    case STRLEN:
      propValObject = stringLegth();
                                 {if (true) return propValObject;}
      break;
    case STRLESS:
      propValObject = stringLess();
                                {if (true) return propValObject;}
      break;
    case STRTOLOWER:
      propValObject = stringToLower();
                                   {if (true) return propValObject;}
      break;
    case STRREPLACEALL:
      propValObject = stringReplaceAll();
                                      {if (true) return propValObject;}
      break;
    case STRSUBSTRING:
      propValObject = stringSegment();
                                   {if (true) return propValObject;}
      break;
    case STRSPLIT:
      propValObject = stringSplit();
                                 {if (true) return propValObject;}
      break;
    case STRSPLITANY:
      propValObject = stringSplitAtAny();
                                      {if (true) return propValObject;}
      break;
    case STRSPLITFIRST:
      propValObject = stringSplitAtFirst();
                                        {if (true) return propValObject;}
      break;
    case STRSPLITFIRSTANY:
      propValObject = stringSplitFirstAny();
                                         {if (true) return propValObject;}
      break;
    case STRSPLITSPACES:
      propValObject = stringSplitSpaces();
                                       {if (true) return propValObject;}
      break;
    case STRSTARTAT:
      propValObject = stringStartsAt();
                                    {if (true) return propValObject;}
      break;
    case STRTRIM:
      propValObject = stringTrim();
                                {if (true) return propValObject;}
      break;
    case STRTOUPPER:
      propValObject = stringToUpper();
                                   {if (true) return propValObject;}
      break;
    case YAILGETITEM:
      propValObject = yailGetListItem();
                                     {if (true) return propValObject;}
      break;
    case YAILISALIST:
      propValObject = yailIsList();
                                {if (true) return propValObject;}
      break;
    case YAILADDTOLIST:
      propValObject = yailListAddToList();
                                       {if (true) return propValObject;}
      break;
    case YAILLISTAPPEND:
      propValObject = yailListAppend();
                                    {if (true) return propValObject;}
      break;
    case DIVIDE:
    case GREATER:
    case LESS:
    case MINUS:
    case MULTIPLY:
    case PLUS:
    case YAILEQUAL:
      propValObject = opBlock();
                             {if (true) return propValObject;}
      break;
    case CLOSEAPP:
      yailControlCloseApp();
                         {if (true) return propValObject;}
      break;
    case IF:
      yailControlChoose();
                       {if (true) return propValObject;}
      break;
    case CLOSESCREEN:
      yailControlCloseScreen();
                            {if (true) return propValObject;}
      break;
    case CLOSESCREENPLAINTEXT:
      yailControlCloseScreenPlainText();
                                     {if (true) return propValObject;}
      break;
    case CLOSESCREENWITHVALUE:
      yailControlCloseScreenWithValue();
                                     {if (true) return propValObject;}
      break;
    case OPENANOTHERSCREEN:
      yailControlOpenAnotherScreen();
                                  {if (true) return propValObject;}
      break;
    case OPENANOTHERSCREENWITHVALUE:
      yailControlOpenAnotherScreenWithValue();
                                           {if (true) return propValObject;}
      break;
    case WHILE:
      yailControlWhile();
                      {if (true) return propValObject;}
      break;
    case YAILLISTCOPY:
      propValObject = yailListCopy();
                                  {if (true) return propValObject;}
      break;
    case YAILLISTINDEX:
      propValObject = yailListInd();
                                 {if (true) return propValObject;}
      break;
    case YAILLISTINSERT:
      yailListInsert();
                    {if (true) return propValObject;}
      break;
    case YAILLISTLENGTH:
      propValObject = yailListLength();
                                    {if (true) return propValObject;}
      break;
    case YAILLISTMEMBER:
      propValObject = yailListMember();
                                    {if (true) return propValObject;}
      break;
    case YAILLISTRANDOM:
      propValObject = yailListPickRandom();
                                        {if (true) return propValObject;}
      break;
    case YAILLISTSETITEM:
      yailListSetItem();
                     {if (true) return propValObject;}
      break;
    case YAILLISTFROMCSVROW:
      propValObject = yailListFromCsvRow();
                                        {if (true) return propValObject;}
      break;
    case YAILLISTFROMCSVTABLE:
      propValObject = yailListFromCsvTable();
                                          {if (true) return propValObject;}
      break;
    case YAILLISTTOCSVROW:
      propValObject = yailListToCsvRow();
                                      {if (true) return propValObject;}
      break;
    case YAILLISTTOCSVTABLE:
      propValObject = yailListToCsvTable();
                                        {if (true) return propValObject;}
      break;
    case ABS:
      propValObject = yailMathAbs();
                                  {if (true) return propValObject;}
      break;
    case ATAN:
      propValObject = yailMathAtan();
                                  {if (true) return propValObject;}
      break;
    case ATAN2:
      propValObject = yailMathAtan2();
                                   {if (true) return propValObject;}
      break;
    case ACOS:
      propValObject = yailMathAcos();
                                  {if (true) return propValObject;}
      break;
    case ASIN:
      propValObject = yailMathAsin();
                                  {if (true) return propValObject;}
      break;
    case CEILING:
      propValObject = yailMathCeiling();
                                     {if (true) return propValObject;}
      break;
    case CONVRADITODEG:
      propValObject = yailMathConvertToDeg();
                                          {if (true) return propValObject;}
      break;
    case CONVDEGTORADI:
      propValObject = yailMathConvertToRad();
                                          {if (true) return propValObject;}
      break;
    case COS:
      propValObject = yailMathcos();
                                 {if (true) return propValObject;}
      break;
    case EXP:
      propValObject = yailMathExp();
                                 {if (true) return propValObject;}
      break;
    case EXPT:
      propValObject = yailMathExpt();
                                  {if (true) return propValObject;}
      break;
    case FLOOR:
      propValObject = yailMathFloor();
                                   {if (true) return propValObject;}
      break;
    case FORMATASDEC:
      propValObject = yailMathFormatAsDec();
                                         {if (true) return propValObject;}
      break;
    case ISANUM:
      propValObject = yailMathIsANum();
                                    {if (true) return propValObject;}
      break;
    case LOG:
      propValObject = yailMathLog();
                                 {if (true) return propValObject;}
      break;
    case MAX:
      propValObject = yailMathMax();
                                 {if (true) return propValObject;}
      break;
    case MIN:
      propValObject = yailMathMin();
                                 {if (true) return propValObject;}
      break;
    case MOD:
      propValObject = yailMathMod();
                                 {if (true) return propValObject;}
      break;
    case SIN:
      propValObject = yailMathsin();
                                 {if (true) return propValObject;}
      break;
    case QUOTIENT:
      propValObject = yailMathQuotient();
                                      {if (true) return propValObject;}
      break;
    case RANDOMSETSEED:
      propValObject = yailMathRandomSeed();
                                        {if (true) return propValObject;}
      break;
    case REMAINDER:
      propValObject = yailMathRemainder();
                                       {if (true) return propValObject;}
      break;
    case ROUND:
      propValObject = yailMathRound();
                                   {if (true) return propValObject;}
      break;
    case SQUAREROOT:
      propValObject = yailMathSqrt();
                                  {if (true) return propValObject;}
      break;
    case TAN:
      propValObject = yailMathtan();
                                 {if (true) return propValObject;}
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList yailPrims() throws ParseException {
 ArrayList propValObject = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CALLPRIM:
      jj_consume_token(CALLPRIM);
      propValObject = yailPrim();
      primName();
   {if (true) return propValObject;}
      break;
    case YAILEQUAL:
      jj_consume_token(YAILEQUAL);
      jj_consume_token(LPAREN);
      compVal();
      jj_consume_token(RPAREN);
      jj_consume_token(LPAREN);
      compVal();
      jj_consume_token(RPAREN);
 {if (true) return propValObject;}
      break;
    case LEXVAL:
      propValObject = variables();
                               {if (true) return propValObject;}
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void buildTable() throws ParseException {
  ArrayList<String > values = new ArrayList();
  values.add("Form");
  values.add("switchForm");
  lookUps.put("open-another-screen", values);

  values = new ArrayList();
  values.add("argsIL");
  values.add("remove");
  values.add("args");
  values.add("setItems");
  lookUps.put("yail-list-remove-item!", values);
  }

  final public String generateCodeString(String yailType, String value) throws ParseException {
    if(yailType.equals("abs")) {if (true) return "Math.abs(" + value + ")";}
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public HashMap<String, AppComponent > getComponents() throws ParseException {
   {if (true) return components;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<CodeBlock> getEvents() throws ParseException {
   {if (true) return events;}
    throw new Error("Missing return statement in function");
  }

  final public String getPackageName() throws ParseException {
   {if (true) return packageName;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<JVar> getVariablesArray() throws ParseException {
   {if (true) return variables;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<Method> getMethods() throws ParseException {
   {if (true) return methods;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public YailParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[44];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x20000100,0x0,0x0,0x0,0x0,0x0,0x0,0x1830000,0x0,0x1830000,0x0,0x0,0x0,0x0,0x1800000,0x0,0x26000,0x0,0x6000,0x0,0x0,0x1800000,0x0,0x1800000,0x0,0x1000000,0x1000000,0x0,0x20000,0x1800000,0x0,0x0,0x0,0x0,0x80000000,0x0,0x1800000,0x30000,0x0,0x0,0x0,0x8e7c1cc0,0x20000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x20001,0x1000000,0x0,0x1000000,0x1000000,0x1000000,0x1000000,0x1116120,0x1000000,0x1116120,0x0,0x0,0x6000,0x2400,0x1006000,0x1000000,0x100400,0x1000000,0x0,0x0,0x600000,0x1006000,0x600000,0x1006000,0x1000000,0x1000000,0x1000000,0x0,0x106400,0x1006000,0x600000,0x0,0x8,0x8,0xa0088000,0x0,0x1006000,0x116400,0x0,0x200000,0x200000,0xfe0d8056,0x100000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x78000,0x0,0x78000,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x8000,0x0,0x8000,0x0,0x8000,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x8,0x0,0x8000,0x0,0x300,0x0,0x0,0xfff82f8b,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x10000000,0x0,0x0,0x80,0x0,0x0,0x8000000,0x0,0x10000b00,0x0,0x10000b00,0x8000000,0x8000000,0x0,0x0,0x10000100,0x0,0x800,0x100,0x0,0x0,0x0,0x10000100,0x0,0x10000100,0x0,0x0,0x0,0x10000000,0x800,0x10000100,0x0,0x8000000,0x0,0x0,0x800,0x10000000,0x10000100,0x800,0x0,0x8000000,0x8000000,0x7fffe7f,0x800,};
   }

  /** Constructor with InputStream. */
  public YailParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public YailParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new YailParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public YailParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new YailParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public YailParser(YailParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(YailParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 44; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[128];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 44; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 128; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
